# 메모리 정리 시뮬레이션

## 문제 설명
운영체제 개발자인 태호는 메모리 파편화를 해결하기 위해 메모리 블록을 재배치하는 시뮬레이션을 진행하고 있습니다. 메모리 상태는 $0$(빈 공간)과 $1$(사용 중인 데이터)로 구성된 문자열로 표현됩니다. 태호는 메모리가 안정적인 상태인 "$11$"이 될 때까지 아래의 **정리 규칙**을 반복합니다.

**[정리 규칙]**
1. 현재 메모리 문자열에서 모든 $0$을 제거하여 데이터를 한곳으로 모읍니다. 이때 제거된 $0$의 개수를 기록합니다.
2. $0$이 제거되고 남은 데이터의 길이를 $L$이라고 할 때, 새로운 메모리 상태를 $L + 2$의 값을 **이진법**으로 변환한 문자열로 교체합니다.

예를 들어, 초기 상태가 "$1101$"이라면 다음과 같은 과정을 거칩니다:
- **1회차:** $0$을 $1$개 제거합니다. 남은 데이터의 길이는 $L=3$입니다. $L+2 = 5$를 이진법으로 변환하면 "$101$"이 됩니다.
- **2회차:** "$101$"에서 $0$을 $1$개 제거합니다. 남은 데이터의 길이는 $L=2$입니다. $L+2 = 4$를 이진법으로 변환하면 "$100$"이 됩니다.
- **3회차:** "$100$"에서 $0$을 $2$개 제거합니다. 남은 데이터의 길이는 $L=1$입니다. $L+2 = 3$을 이진법으로 변환하면 "$11$"이 됩니다.
- **종료:** 메모리 상태가 "$11$"이 되었으므로 시뮬레이션을 종료합니다.

태호를 도와 초기 메모리 상태 $s$가 주어졌을 때, 종료될 때까지의 **총 정리 횟수**와 **제거된 $0$의 총 개수**를 구하는 프로그램을 작성해 주세요.

---
## 입력 형식 (Input Format)
- 첫 번째 줄에 $0$과 $1$로 이루어진 문자열 $s$가 주어집니다.
- $s$의 길이는 $2$ 이상 $150,000$ 이하입니다.
- $s$에는 적어도 하나 이상의 '$1$'이 포함되어 있으며, 초기 상태가 이미 "$11$"인 경우는 주어지지 않습니다.

## 출력 형식 (Output Format)
- 총 정리 횟수와 제거된 $0$의 총 개수를 공백으로 구분하여 출력합니다.

---
## 입출력 예시 (Sample I/O)

### 예시 1
**Input:**
```
1101
```
**Output:**
```
3 4
```

- 1회: `1101` 
  - $0$ 1개 제거, $L=3$ -> $3+2=5$(`101`)
- 2회: `101` 
  - $0$ 1개 제거, $L=2$ -> $2+2=4$(`100`)
- 3회: `100` 
  - $0$ 2개 제거, $L=1$ -> $1+2=3$(`11`)
- 종료 조건 `11`에 도달했습니다. 횟수 3회, $0$ 제거 합계 4개입니다.

### 예시 2
**Input:**
```
111
```
**Output:**
```
2 1
```

- 1회: `111` 
  - $0$ 0개 제거, $L=3$ -> $3+2=5$(`101`)
- 2회: `101` 
  - $0$ 1개 제거, $L=2$ -> $2+2=4$(`100`)
- 3회: `100` 
  - $0$ 2개 제거, $L=1$ -> $1+2=3$(`11`)
- 총 3회의 변환과 3개의 $0$이 제거됩니다.

### 예시 3
**Input:**
```
1000001
```
**Output:**
```
2 7
```

- `1000001` 
  - 길이 7, $0$ 5개 제거, $L=2$ -> $2+2=4$(`100`)
- `100` 
  - 길이 3, $0$ 2개 제거, $L=1$ -> $1+2=3$(`11`)
- 총 2회 변환, $0$ 제거 합계 7개입니다.

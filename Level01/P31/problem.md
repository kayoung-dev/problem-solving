# 시스템 에뮬레이터의 서브루틴 추적

## 문제 설명
컴퓨터 아키텍처를 전공하는 엔지니어 **레이나**는 새로운 명령어 집합 구조(ISA)를 위한 시스템 에뮬레이터를 개발하고 있습니다. 이 에뮬레이터는 프로그램의 제어 흐름을 관리하기 위해 $PC(Program \,\, Counter)$를 사용하며, 현재 실행 중인 명령어의 주소를 추적합니다.

에뮬레이터가 함수를 처리하는 방식은 다음과 같습니다:

1. 초기 $PC(Program \,\, Counter)$ 값은 **0**에서 시작합니다.
2. `CALL addr`: 현재 명령어의 다음 주소($PC + 1$)를 시스템 스택에 저장(Push)하고, $PC(Program \,\, Counter)$를 $addr$로 즉시 변경합니다.
3. `RET`: 시스템 스택의 최상단에 저장된 주소를 꺼내(Pop) $PC(Program \,\, Counter)$에 대입합니다. 만약 스택이 비어 있어 복귀할 주소가 없다면 `STACK_ERROR`를 발생시키고 시뮬레이션을 중단합니다.

명령어 시퀀스가 주어질 때, 각 명령어를 수행한 직후의 $PC(Program \,\, Counter)$ 값을 출력하는 프로그램을 작성하세요.

---

## 입력 형식 (Input Format)
* 첫 번째 줄부터 명령어들이 한 줄에 하나씩 주어집니다.
* 명령어의 총 개수는 $1$개 이상 $100,000$개 이하입니다.
* `CALL addr`에서 $addr$는 $1$ 이상 $10^9$ 이하의 정수입니다.

## 출력 형식 (Output Format)
* 각 명령어를 수행한 직후의 $PC(Program \,\, Counter)$ 값을 한 줄에 하나씩 출력합니다.
* `RET` 실행 시 스택이 비어 있다면 `STACK_ERROR`를 출력하고 프로그램을 즉시 종료합니다.

---

## 입출력 예시 (Sample I/O)

### 예시 1
**Input:**
```
CALL 1024
CALL 2048
RET
RET
```

**Output:**
```
1024
2048
1025
1
```

* `CALL 1024`: 복귀 주소 **1**을 스택에 저장하고 $PC(Program \,\, Counter)$는 **1024**가 됩니다.
* `CALL 2048`: 복귀 주소 **1025**를 스택에 저장하고 $PC(Program \,\, Counter)$는 **2048**가 됩니다.
* `RET`: 스택에서 **1025**를 꺼내 $PC(Program \,\, Counter)$에 저장합니다.
* `RET`: 스택에서 **1**을 꺼내 $PC(Program \,\, Counter)$에 저장합니다.

### 예시 2
**Input:**
```
CALL 512
RET
RET
```

**Output:**
```
512
1
STACK_ERROR
```

* 두 번째 `RET` 연산 시 스택이 비어 있으므로 오류 메시지를 출력하고 종료합니다.

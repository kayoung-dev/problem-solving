# 점수 로그 복구

## 문제 설명
한 자동 채점 시스템은 시험을 여러 단계로 채점합니다.  
정상적인 기록이라면, 단계가 진행될수록 점수는 **앞 단계보다 항상 더 큰 값**이 됩니다.

하지만 기록 오류로 인해, 일부 단계의 점수가 잘못 저장되었습니다.  
시스템은 오류를 수정하기 위해 **정상 후보 점수 목록**을 가지고 있습니다.

- 현재 기록된 점수 로그: $A = [a_1, a_2, \dots, a_N]$
- 후보 점수 목록: $B = [b_1, b_2, \dots, b_M]$

한 번의 수정 작업에서는 어떤 단계 $i$를 골라, 점수 $a_i$를 후보 점수 중 하나로 바꿀 수 있습니다.

$a_i \leftarrow b_j$

단, 기록 보존 규칙 때문에 **수정 후 점수는 원래 기록보다 낮아질 수 없습니다.**  
즉, 수정한다면 반드시 다음을 만족해야 합니다.

$b_j \ge a_i$

목표는 점수 로그가 모든 단계에서 다음 조건을 만족하도록 만드는 것입니다.

$a_1 < a_2 < \cdots < a_N$

점수 로그를 이 조건에 맞게 만들기 위한 **최소 수정 횟수**를 구하세요.  
만약 어떤 방법으로도 만들 수 없다면 **-1**을 출력하세요.

---

## 입력 형식 (Input Format)
- 첫째 줄에 점수 로그 개수가 정수 $N$으로 주어집니다. 
- $1 \le N \le 2000$
- 둘째 줄에 $N$개의 정수 $a_1, a_2, \dots, a_N$이 공백으로 주어집니다. ($a_i$는 $i$번째 단계의 현재 점수)
- 셋째 줄에 후보 점수 개수가 정수 $M$으로 주어집니다.
- $1 \le M \le 2000$
- 넷째 줄에 $M$개의 정수 $b_1, b_2, \dots, b_M$이 공백으로 주어집니다. ($b_j$는 후보 점수)
- $1 \le a_i, b_j \le 10^9$
---

## 출력 형식 (Output Format)
- 최소 수정 횟수를 출력합니다.
- 이미 모든 단계에서 점수가 계속 증가한다면, 수정이 필요없으므로 0을 출력합니다.
- 불가능하면 -1을 출력합니다.

---

## 입출력 예시 (Sample I/O)

### 예시 1
**Input:**
```
4
3 3 5 4
3
4 6 7
```

**Output:**
```
2
```

- 현재 로그: $[3, 3, 5, 4]$  
  목표는 **앞 단계보다 항상 더 큰 점수**가 되도록 만드는 것입니다.
- 2번째 단계에서 $3$은 바로 앞의 $3$보다 크지 않으므로 규칙이 깨집니다.
  - 후보 점수 중에서 **원래 점수보다 낮아지지 않으면서**($\ge 3$) 앞 단계보다 큰 값이 필요합니다.
  - 후보에서 $4$를 선택해 2번째 점수를 $4$로 바꾸면 $[3, 4, 5, 4]$가 됩니다. (수정 1회)
- 이제 마지막 단계에서 $4$는 앞의 $5$보다 크지 않으므로 다시 규칙이 깨집니다.
  - 후보에서 $6$을 선택해 마지막 점수를 $6$으로 바꾸면 $[3, 4, 5, 6]$이 됩니다. (수정 2회)
- 모든 단계가 계속 커지므로 최소 수정 횟수는 **2**입니다.

---

### 예시 2
**Input:**
```
7
1 2 2 2 2 4 10
4
3 5 6 7
```

**Output:**
```
4
```

- 현재 로그에서 3~5번째 값이 모두 2라서, 앞 단계보다 계속 커지게 만들려면 **연속으로 여러 번 수정**이 필요합니다.
- 3번째를 3으로 바꾸면: $[1, 2, 3, 2, 2, 4, 10]$ (1회)
- 4번째는 3보다 커야 하므로 5로 바꾸면: $[1, 2, 3, 5, 2, 4, 10]$ (2회)
- 5번째는 5보다 커야 하므로 6으로 바꾸면: $[1, 2, 3, 5, 6, 4, 10]$ (3회)
- 6번째는 6보다 커야 하므로 7로 바꾸면: $[1, 2, 3, 5, 6, 7, 10]$ (4회)
- 이제 모든 단계에서 점수가 계속 커지므로 최소 수정 횟수는 **4**입니다.

---

### 예시 3
**Input:**
```
3
5 4 3
4
4 4 4 5
```

**Output:**
```
-1
```

---

## 힌트(Note)
후보 점수 목록을 정렬해 두면, 어떤 값 이상인 후보 점수 중에서 **가장 작은 값**을 빠르게 고를 수 있습니다.  
각 단계에서 “그대로 둘지 / 후보 점수로 바꿀지”를 비교하며, 전체 수정 횟수가 최소가 되도록 선택해 보세요.

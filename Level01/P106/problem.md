# 로그 검색 우선순위

## 문제 설명
서버 관리자 **은지**는 서비스 장애를 분석하기 위해 로그를 검색하는 일을 자주 합니다.

로그는 `로그ID`, `발생시각`, `중요도`, `메시지(단어들)`로 이루어져 있습니다.  
은지는 검색 속도를 높이기 위해, 메시지에 포함된 단어들을 이용해 **역색인(inverted file)** 을 구성해 두었습니다.

사용자가 여러 개의 검색어를 입력하면, 은지는 역색인을 이용해 검색 결과 로그를 모은 뒤
다음 기준으로 정렬해 상위 K개만 확인하려고 합니다.

각 로그에 대해 아래 값을 계산합니다.

- `hit`: 검색어 중 **서로 다른 단어**가 해당 로그 메시지에 포함된 개수
- `freq`: 해당 로그에서 검색어가 등장한 **총 횟수**
- `severity`: 중요도 (정수, 값이 클수록 더 중요)
- `time`: 발생 시각 (YYYYMMDDHHMM 정수, 값이 클수록 더 최근)

정렬 우선순위는 다음과 같습니다.

1. `hit`가 큰 로그가 먼저
2. `hit`가 같다면 `severity`가 큰 로그가 먼저
3. 위까지 같다면 `freq`가 큰 로그가 먼저
4. 위까지 같다면 `time`이 더 최근인 로그가 먼저
5. 위까지 같다면 로그ID가 작은 로그가 먼저

검색어가 하나도 포함되지 않은 로그는 결과에서 제외합니다.

정렬된 결과에서 상위 K개의 로그ID를 공백으로 출력하세요.

---

## 입력 형식
- 첫 줄에 로그 개수 N이 주어집니다.
- 다음 N줄에 `로그ID 발생시각 중요도 단어개수 단어1 단어2 ...` 가 주어집니다.
- 다음 줄에 검색어 개수 Q가 주어집니다.
- 다음 줄에 Q개의 검색어가 공백으로 주어집니다.
- 마지막 줄에 정수 K가 주어집니다.

---

## 출력 형식
- 조건에 맞게 정렬된 결과에서 상위 K개의 로그ID를 공백으로 출력합니다.
- 출력할 로그가 없다면 빈 줄을 출력합니다.

---

## 입출력 예시 (Sample I/O)

### 예시 1
**Input:**
```
4
1 202601021010 3 5 api error timeout api db
2 202601021005 5 3 error auth fail
3 202601021020 4 4 api cache miss error
4 202512311200 5 2 deploy success
2
api error
3
```

**Output:**
```
3 1 2
```
- 검색어는 `api`, `error` 입니다.
- 각 로그의 hit와 freq는 다음과 같습니다.
  - 로그 1: 메시지에 api(2회), error(1회) 포함 <br/>hit=2, freq=3, severity=3, time=202601021010
  - 로그 2: 메시지에 error(1회)만 포함 <br/>hit=1, freq=1, severity=5, time=202601021005
  - 로그 3: 메시지에 api(1회), error(1회) 포함 <br/>hit=2, freq=2, severity=4, time=202601021020
  - 로그 4: 검색어가 없음 → 결과에서 제외
- 정렬 과정:
  - hit가 큰 로그(로그 1,3)가 먼저 옵니다. (둘 다 hit=2)
  - hit가 같으면 severity가 큰 로그가 먼저이므로, severity=4인 로그 3이 severity=3인 로그 1보다 앞입니다.
  - hit가 1인 로그 2는 그 다음에 옵니다.
- 따라서 상위 3개 결과는 `3 1 2` 입니다.

### 예시 2
**Input:**
```
5
10 202601010900 2 4 db slow query db
11 202601010905 2 3 db fail error
12 202601010910 5 4 api db fail timeout
13 202601010915 3 2 fail fail
14 202601010920 4 3 api error fail
3
db fail api
4
```

**Output:**
```
12 14 11 13
```
- 검색어는 `db`, `fail`, `api` 입니다.
- 로그별 hit를 보면:
  - 로그 12: db, fail, api 모두 포함 <br/>hit=3 (가장 우선)
  - 로그 14: api, fail 포함 <br/>hit=2
  - 로그 11: db, fail 포함 <br/>hit=2
  - 로그 13: fail만 포함 <br/>hit=1
  - 로그 10: db만 포함 <br/>hit=1 (하지만 K=4라서 최종 출력에서 밀림)
- hit가 같은 그룹에서는 severity가 큰 로그가 먼저입니다.
  - (hit=2 그룹) 로그 14(sev=4) > 로그 11(sev=2)
  - (hit=1 그룹) 로그 13(sev=3) > 로그 10(sev=2)
- 따라서 상위 4개 결과는 `12 14 11 13` 입니다.


### 예시 3
**Input:**
```
2
7 202601011000 5 2 cache hit
8 202601011005 4 2 api ok
1
error
5
```

**Output:**
```

```
